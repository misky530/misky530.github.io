## 任务2.3: Volume - 数据持久化

容器默认是临时的，重启后数据丢失。Volume用于持久化数据或在容器间共享数据。

### 1. EmptyDir - 临时存储

Pod内容器共享数据，Pod删除后数据消失：

```yaml
cat > emptydir-demo.yaml << 'EOF'
apiVersion: v1
kind: Pod
metadata:
  name: shared-volume-pod
spec:
  containers:
  # 写入容器
  - name: writer
    image: busybox
    command: ["/bin/sh", "-c"]
    args:
    - |
      while true; do
        echo "$(date): Message from writer" >> /data/log.txt
        sleep 5
      done
    volumeMounts:
    - name: shared-data
      mountPath: /data
  
  # 读取容器
  - name: reader
    image: busybox
    command: ["/bin/sh", "-c"]
    args:
    - |
      while true; do
        echo "=== Latest 5 lines ==="
        tail -5 /data/log.txt 2>/dev/null || echo "No data yet"
        sleep 10
      done
    volumeMounts:
    - name: shared-data
      mountPath: /data
  
  volumes:
  - name: shared-data
    emptyDir: {}  # 临时目录
EOF

kubectl apply -f emptydir-demo.yaml
```

验证数据共享：

```bash
# 查看writer的日志
kubectl logs shared-volume-pod -c writer

# 查看reader的日志（应该能看到writer写入的内容）
kubectl logs shared-volume-pod -c reader

# 进入容器查看
kubectl exec -it shared-volume-pod -c reader -- cat /data/log.txt

# 删除Pod后重建
kubectl delete pod shared-volume-pod
kubectl apply -f emptydir-demo.yaml

# 查看reader日志 - 数据丢失了
kubectl logs shared-volume-pod -c reader
```

**EmptyDir的用途**：

- 缓存数据
- 临时文件
- 多容器协作（一个生成数据，另一个处理）

### 2. HostPath - 挂载节点目录

将节点的目录挂载到Pod：

```yaml
cat > hostpath-demo.yaml << 'EOF'
apiVersion: v1
kind: Pod
metadata:
  name: hostpath-pod
spec:
  containers:
  - name: nginx
    image: nginx:alpine
    volumeMounts:
    - name: host-data
      mountPath: /usr/share/nginx/html
  volumes:
  - name: host-data
    hostPath:
      path: /tmp/k8s-data
      type: DirectoryOrCreate  # 目录不存在则创建
EOF

kubectl apply -f hostpath-demo.yaml
```

验证：

```bash
# 查看Pod在哪个节点
kubectl get pod hostpath-pod -o wide

# 假设在worker-1 (192.168.56.21)
# 在该节点创建文件
ssh vagrant@192.168.56.21 "echo '<h1>Hello from HostPath!</h1>' | sudo tee /tmp/k8s-data/index.html"

# 访问nginx
kubectl port-forward pod/hostpath-pod 8080:80 &
curl http://localhost:8080
killall kubectl

# 删除Pod后数据仍在节点上
kubectl delete pod hostpath-pod
ssh vagrant@192.168.56.21 "cat /tmp/k8s-data/index.html"
```

**HostPath的问题**：

- Pod可能调度到不同节点，数据就访问不到了
- 只适合单节点测试或特定用途（如访问节点日志）

### 3. ConfigMap/Secret作为Volume

前面已经演示过，这里对比一下：

```yaml
cat > volume-types-comparison.yaml << 'EOF'
apiVersion: v1
kind: Pod
metadata:
  name: volume-types
spec:
  containers:
  - name: app
    image: busybox
    command: ["sleep", "3600"]
    volumeMounts:
    # EmptyDir
    - name: cache
      mountPath: /cache
    # ConfigMap
    - name: config
      mountPath: /etc/config
    # Secret
    - name: secrets
      mountPath: /etc/secrets
      readOnly: true
  volumes:
  - name: cache
    emptyDir:
      sizeLimit: 100Mi  # 限制大小
  - name: config
    configMap:
      name: app-config
      items:
      - key: database.url
        path: db.conf
  - name: secrets
    secret:
      secretName: db-secret
      defaultMode: 0400
EOF

# 先创建ConfigMap和Secret
kubectl create configmap app-config --from-literal=database.url="mysql://db:3306"
kubectl create secret generic db-secret --from-literal=password="secret123"

kubectl apply -f volume-types-comparison.yaml

# 验证
kubectl exec volume-types -- sh -c "ls -la /cache /etc/config /etc/secrets"
```

### 4. 实际案例：日志收集

EmptyDir的典型用途 - 应用写日志，sidecar收集：

```yaml
cat > log-collector.yaml << 'EOF'
apiVersion: v1
kind: Pod
metadata:
  name: app-with-logging
spec:
  containers:
  # 主应用
  - name: app
    image: busybox
    command: ["/bin/sh", "-c"]
    args:
    - |
      while true; do
        echo "[$(date)] Application log entry" >> /var/log/app/app.log
        sleep 3
      done
    volumeMounts:
    - name: logs
      mountPath: /var/log/app
  
  # 日志收集器（sidecar）
  - name: log-shipper
    image: busybox
    command: ["/bin/sh", "-c"]
    args:
    - |
      tail -f /var/log/app/app.log | while read line; do
        echo "[SHIPPED] $line"
      done
    volumeMounts:
    - name: logs
      mountPath: /var/log/app
      readOnly: true
  
  volumes:
  - name: logs
    emptyDir: {}
EOF

kubectl apply -f log-collector.yaml

# 查看日志收集器的输出
kubectl logs app-with-logging -c log-shipper
```

### 5. Volume类型总结

| Volume类型            | 生命周期 | 用途           | 生产环境   |
| --------------------- | -------- | -------------- | ---------- |
| emptyDir              | Pod级别  | 临时数据、缓存 | ✓          |
| hostPath              | 节点级别 | 访问节点文件   | ⚠️ 谨慎使用 |
| configMap             | 独立     | 配置文件       | ✓          |
| secret                | 独立     | 敏感信息       | ✓          |
| persistentVolumeClaim | 独立     | 持久化数据     | ✓✓✓        |

**注意**：

- emptyDir和hostPath数据不持久
- 真正的持久化需要PersistentVolume（下次学习）

### 清理

```bash
kubectl delete pod shared-volume-pod hostpath-pod volume-types app-with-logging
kubectl delete configmap app-config
kubectl delete secret db-secret
ssh vagrant@192.168.56.21 "sudo rm -rf /tmp/k8s-data"
rm emptydir-demo.yaml hostpath-demo.yaml volume-types-comparison.yaml log-collector.yaml
```

------

## 第二部分总结

你已经掌握了：

1. ConfigMap

    \- 将配置与代码分离

   - 环境变量注入
   - 文件挂载

2. Secret

    \- 管理敏感信息

   - base64编码，不是加密
   - 生产需要外部密钥管理

3. Volume

    \- 数据管理

   - emptyDir：Pod内共享
   - hostPath：访问节点
   - configMap/secret：配置注入

明天可以学习：

- PersistentVolume持久化存储
- 或者直接做实战项目（部署WordPress）

现在想继续还是休息一下？