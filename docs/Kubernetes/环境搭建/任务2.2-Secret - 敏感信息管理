## 任务2.2: Secret - 敏感信息管理

Secret用于存储密码、token、密钥等敏感数据。虽然也是base64编码，但：

- Kubernetes会特殊处理（如限制访问权限）
- 可以集成外部密钥管理系统（Vault）
- 在etcd中可以加密存储

### 创建Secret

```bash
# 方法1: 从字面值创建
kubectl create secret generic db-secret \
  --from-literal=username=admin \
  --from-literal=password='MyP@ssw0rd123!'

# 查看Secret（数据被隐藏）
kubectl get secret db-secret

# 查看详细内容（base64编码）
kubectl get secret db-secret -o yaml

# 手动解码查看
kubectl get secret db-secret -o jsonpath='{.data.password}' | base64 -d
echo
```

### 创建不同类型的Secret

```bash
# Docker registry认证
kubectl create secret docker-registry regcred \
  --docker-server=docker.io \
  --docker-username=myuser \
  --docker-password=mypassword \
  --docker-email=email@example.com

# TLS证书（模拟）
openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
  -keyout tls.key -out tls.crt \
  -subj "/CN=example.com/O=example"

kubectl create secret tls tls-secret \
  --cert=tls.crt \
  --key=tls.key
```

### 使用Secret

```yaml
cat > pod-with-secret.yaml << 'EOF'
apiVersion: v1
kind: Pod
metadata:
  name: app-with-secret
spec:
  containers:
  - name: app
    image: busybox
    command: ["/bin/sh", "-c"]
    args:
    - |
      echo "=== Secret as Environment Variables ==="
      echo "Username: $DB_USER"
      echo "Password: $DB_PASS (hidden in production)"
      echo ""
      echo "=== Secret as Files ==="
      echo "Username from file: $(cat /secrets/username)"
      echo "Password from file: $(cat /secrets/password)"
      echo ""
      sleep 3600
    # 方式1: 环境变量
    env:
    - name: DB_USER
      valueFrom:
        secretKeyRef:
          name: db-secret
          key: username
    - name: DB_PASS
      valueFrom:
        secretKeyRef:
          name: db-secret
          key: password
    # 方式2: 挂载为文件（更安全）
    volumeMounts:
    - name: secret-volume
      mountPath: /secrets
      readOnly: true  # 只读挂载
  volumes:
  - name: secret-volume
    secret:
      secretName: db-secret
      defaultMode: 0400  # 文件权限：只读
EOF

kubectl apply -f pod-with-secret.yaml
```

### 验证Secret注入

```bash
# 查看日志
kubectl logs app-with-secret

# 进入容器验证
kubectl exec -it app-with-secret -- sh
# 在容器内:
# echo $DB_USER
# cat /secrets/username
# ls -la /secrets/  # 查看文件权限
# exit
```

### Secret vs ConfigMap 对比

```bash
# 创建对比示例
cat > secret-vs-configmap.yaml << 'EOF'
apiVersion: v1
kind: ConfigMap
metadata:
  name: public-config
data:
  api.endpoint: "https://api.example.com"
  cache.ttl: "3600"
---
apiVersion: v1
kind: Secret
metadata:
  name: private-config
type: Opaque
stringData:  # stringData会自动base64编码
  api.key: "sk-1234567890abcdef"
  api.secret: "secret-key-here"
---
apiVersion: v1
kind: Pod
metadata:
  name: config-comparison
spec:
  containers:
  - name: app
    image: busybox
    command: ["sleep", "3600"]
    env:
    # ConfigMap
    - name: API_ENDPOINT
      valueFrom:
        configMapKeyRef:
          name: public-config
          key: api.endpoint
    # Secret
    - name: API_KEY
      valueFrom:
        secretKeyRef:
          name: private-config
          key: api.key
    volumeMounts:
    - name: config
      mountPath: /config
    - name: secrets
      mountPath: /secrets
      readOnly: true
  volumes:
  - name: config
    configMap:
      name: public-config
  - name: secrets
    secret:
      secretName: private-config
      defaultMode: 0400
EOF

kubectl apply -f secret-vs-configmap.yaml

# 验证
kubectl exec config-comparison -- sh -c "echo '=== ConfigMap ==='; cat /config/*; echo; echo '=== Secret ==='; cat /secrets/*"
```

### 最佳实践

```bash
# 1. 永远不要在代码中硬编码Secret
# 2. 使用stringData而非data（更易读）
# 3. Secret挂载为文件时设置readOnly
# 4. 在生产环境使用外部密钥管理（Vault、云KMS）
```

### 清理

```bash
kubectl delete pod app-with-secret config-comparison
kubectl delete secret db-secret regcred tls-secret private-config
kubectl delete configmap public-config
rm pod-with-secret.yaml secret-vs-configmap.yaml tls.key tls.crt
```

------

完成这个任务后，试着回答：

1. Secret和ConfigMap的主要区别是什么？
2. 为什么说Secret也不是完全安全的？
3. 在生产环境中应该如何管理敏感信息？

然后我们继续任务2.3 Volume的学习。

然后我们继续任务2.3 Volume的学习。

AC

secret只能看到字节长度,并不能看到真实的内容. * Secret和ConfigMap的主要区别是什么？ 用法不一样,secret本身就是加密过的,一般用于db user,db password, 而configMap主要用于配置信息 * 为什么说Secret也不是完全安全的？ 因为base64可以解密 * 在生产环境中应该如何管理敏感信息？ 这个不知道,请回答

Edit

你的理解基本正确，我来补充和纠正一些点：

## 关于你的回答

**Secret和ConfigMap的区别**：

- ✅ 用途不同：Secret用于敏感信息，ConfigMap用于普通配置
- ⚠️ 加密方式：Secret默认只是base64**编码**，不是加密。在etcd中也是明文存储（除非配置了etcd加密）

**为什么不完全安全**：

- ✅ base64是编码，不是加密，可以轻易解码
- 补充：任何有权限访问Secret的人都能看到内容
- 补充：Secret会被挂载到容器内存中，容器被攻破就能读取

## 生产环境管理敏感信息的方案

### 1. **外部密钥管理系统（推荐）**

**HashiCorp Vault**：

bash

```bash
# Vault存储Secret，K8s动态获取
# Pod启动时从Vault读取，用完即删
# Secret不存储在K8s etcd中
```

**云厂商KMS**：

- AWS Secrets Manager
- Azure Key Vault
- 阿里云KMS
- 腾讯云SSM

### 2. **Sealed Secrets**

加密Secret后存储在Git：

bash

```bash
# 安装Sealed Secrets Controller
kubectl apply -f https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.18.0/controller.yaml

# 加密Secret
kubeseal < mysecret.yaml > mysealedsecret.yaml

# mysealedsecret.yaml可以安全地提交到Git
# Controller会自动解密成普通Secret
```

### 3. **启用etcd加密**

K8s配置etcd加密存储：

yaml

```yaml
# /etc/kubernetes/encryption-config.yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
  - resources:
    - secrets
    providers:
    - aescbc:
        keys:
        - name: key1
          secret: <base64 encoded secret>
    - identity: {}
```

### 4. **RBAC严格控制**

最小权限原则：

yaml

```yaml
# 只给必要的ServiceAccount Secret权限
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: secret-reader
rules:
- apiGroups: [""]
  resources: ["secrets"]
  resourceNames: ["specific-secret"]  # 只能读取特定Secret
  verbs: ["get"]
```

### 5. **生产环境最佳实践**

```
1. 使用外部密钥管理系统（Vault/云KMS）
   ↓
2. 如果必须用K8s Secret：
   - 启用etcd加密
   - 使用Sealed Secrets管理
   - 严格RBAC控制
   ↓
3. 应用层：
   - 环境变量只存引用，不存值
   - 敏感数据只在内存中，不写磁盘
   - 使用后立即清除
   ↓
4. 审计：
   - 启用审计日志
   - 监控Secret访问
   - 定期轮换密钥
```

### 6. **简单示例：使用Vault**

yaml

```yaml
apiVersion: v1
kind: Pod
metadata:
  annotations:
    vault.hashicorp.com/agent-inject: "true"
    vault.hashicorp.com/agent-inject-secret-db: "secret/data/database"
    vault.hashicorp.com/role: "myapp"
spec:
  serviceAccountName: myapp
  containers:
  - name: app
    image: myapp:v1
    # Secret会被注入到 /vault/secrets/db
```

------

## 总结

生产环境敏感信息管理：

1. **首选**：外部密钥管理系统（Vault、云KMS）
2. **次选**：K8s Secret + etcd加密 + Sealed Secrets
3. **必须**：严格的RBAC权限控制
4. **配合**：审计、监控、定期轮换

K8s的Secret只是基础设施，真正的安全需要多层防护。