## 任务2.2: Secret - 敏感信息管理

Secret用于存储密码、token、密钥等敏感数据。虽然也是base64编码，但：

- Kubernetes会特殊处理（如限制访问权限）
- 可以集成外部密钥管理系统（Vault）
- 在etcd中可以加密存储

### 创建Secret

```bash
# 方法1: 从字面值创建
kubectl create secret generic db-secret \
  --from-literal=username=admin \
  --from-literal=password='MyP@ssw0rd123!'

# 查看Secret（数据被隐藏）
kubectl get secret db-secret

# 查看详细内容（base64编码）
kubectl get secret db-secret -o yaml

# 手动解码查看
kubectl get secret db-secret -o jsonpath='{.data.password}' | base64 -d
echo
```

### 创建不同类型的Secret

```bash
# Docker registry认证
kubectl create secret docker-registry regcred \
  --docker-server=docker.io \
  --docker-username=myuser \
  --docker-password=mypassword \
  --docker-email=email@example.com

# TLS证书（模拟）
openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
  -keyout tls.key -out tls.crt \
  -subj "/CN=example.com/O=example"

kubectl create secret tls tls-secret \
  --cert=tls.crt \
  --key=tls.key
```

### 使用Secret

```yaml
cat > pod-with-secret.yaml << 'EOF'
apiVersion: v1
kind: Pod
metadata:
  name: app-with-secret
spec:
  containers:
  - name: app
    image: busybox
    command: ["/bin/sh", "-c"]
    args:
    - |
      echo "=== Secret as Environment Variables ==="
      echo "Username: $DB_USER"
      echo "Password: $DB_PASS (hidden in production)"
      echo ""
      echo "=== Secret as Files ==="
      echo "Username from file: $(cat /secrets/username)"
      echo "Password from file: $(cat /secrets/password)"
      echo ""
      sleep 3600
    # 方式1: 环境变量
    env:
    - name: DB_USER
      valueFrom:
        secretKeyRef:
          name: db-secret
          key: username
    - name: DB_PASS
      valueFrom:
        secretKeyRef:
          name: db-secret
          key: password
    # 方式2: 挂载为文件（更安全）
    volumeMounts:
    - name: secret-volume
      mountPath: /secrets
      readOnly: true  # 只读挂载
  volumes:
  - name: secret-volume
    secret:
      secretName: db-secret
      defaultMode: 0400  # 文件权限：只读
EOF

kubectl apply -f pod-with-secret.yaml
```

### 验证Secret注入

```bash
# 查看日志
kubectl logs app-with-secret

# 进入容器验证
kubectl exec -it app-with-secret -- sh
# 在容器内:
# echo $DB_USER
# cat /secrets/username
# ls -la /secrets/  # 查看文件权限
# exit
```

### Secret vs ConfigMap 对比

```bash
# 创建对比示例
cat > secret-vs-configmap.yaml << 'EOF'
apiVersion: v1
kind: ConfigMap
metadata:
  name: public-config
data:
  api.endpoint: "https://api.example.com"
  cache.ttl: "3600"
---
apiVersion: v1
kind: Secret
metadata:
  name: private-config
type: Opaque
stringData:  # stringData会自动base64编码
  api.key: "sk-1234567890abcdef"
  api.secret: "secret-key-here"
---
apiVersion: v1
kind: Pod
metadata:
  name: config-comparison
spec:
  containers:
  - name: app
    image: busybox
    command: ["sleep", "3600"]
    env:
    # ConfigMap
    - name: API_ENDPOINT
      valueFrom:
        configMapKeyRef:
          name: public-config
          key: api.endpoint
    # Secret
    - name: API_KEY
      valueFrom:
        secretKeyRef:
          name: private-config
          key: api.key
    volumeMounts:
    - name: config
      mountPath: /config
    - name: secrets
      mountPath: /secrets
      readOnly: true
  volumes:
  - name: config
    configMap:
      name: public-config
  - name: secrets
    secret:
      secretName: private-config
      defaultMode: 0400
EOF

kubectl apply -f secret-vs-configmap.yaml

# 验证
kubectl exec config-comparison -- sh -c "echo '=== ConfigMap ==='; cat /config/*; echo; echo '=== Secret ==='; cat /secrets/*"
```

### 最佳实践

```bash
# 1. 永远不要在代码中硬编码Secret
# 2. 使用stringData而非data（更易读）
# 3. Secret挂载为文件时设置readOnly
# 4. 在生产环境使用外部密钥管理（Vault、云KMS）
```

### 清理

```bash
kubectl delete pod app-with-secret config-comparison
kubectl delete secret db-secret regcred tls-secret private-config
kubectl delete configmap public-config
rm pod-with-secret.yaml secret-vs-configmap.yaml tls.key tls.crt
```

------

完成这个任务后，试着回答：

1. Secret和ConfigMap的主要区别是什么？
2. 为什么说Secret也不是完全安全的？
3. 在生产环境中应该如何管理敏感信息？

然后我们继续任务2.3 Volume的学习。