**微服务详解——什么是微服务？为什么需要微服务？如何实现微服务？**

(74) 微服务详解——什么是微服务？为什么需要微服务？如何实现微服务？ - YouTube

https://www.youtube.com/watch?v=rv4LlmLmVWk

 

文字记录：

(00:00) 在本视频中，我将探讨微服务架构。首先解析解读架构应用架构的定义、其面临的挑战，以及行业逐步转向微服务架构的原因。接着我们将解析微服务架构的准确定义、最佳实践、优势特性，并揭示微服务架构的实际运行机制。另外介绍微服务应用的多种代码管理方案，并探讨

(00:37) 单仓库与多仓库的同类及其优劣势。那么让我们开始吧。在微服务出现时，应用程序的标准开发方式是采用重型仓库。这意味着应用程序的所有组件——基本上整个代码库——都属于单一单元。例如，如果我们有一个在线商店应用程序，其所有部分（如用户认证、购物车、产品目录、促销前活动通知等）的功能代码都将作为异货架程序的上部程序存在于同一个代码库中。

(01:17) 应用程序。所有开发、部署和扩展操作都以整体形式进行，这意味着应用必须采用单一编程语言、技术栈和运行时环境。若不同团队应用的不同模块，则需协调确保互不干扰。另外，当开发人员修改支付功能代码时，必须重新构建整个应用并作为整体包部署——仅无法更新支付模块单独部署。

(01:50)功能变更无法独立处理。这种模式曾是应用开发的标准方式，但随着规模与复杂度增长，逐渐暴露出挑战：首先，团队协作高峰——代码体量膨胀导致各模块相互补充；其次，当特定模块（如节假日期间的购物车功能应用）突发访问高峰时，无法实现局部扩展，必须整体扩容。

(02:24) 这反过来意味着更高的基础成本设施，以及在应用程序的弹性扩展方面灵活性降低。另一个问题是，例如支付功能使用了版本1.8的第三方模块，而通知功能也相同模块但要求1.7版本。在标准化应用中，你只能二选一，因为这是单一应用程序，同一模块只能是一个依赖项。标准化应用的另一个主要问题是

(03:00)发布流程持续时间更长——任何模块功能的变更都需要测试并构建整个应用部署。而微服务架构正好解决了这些问题的答案。那么微服务到底是什么？通过微服务，我们将应用拆解为多个小型应用，由若干微应用共同构成大型应用。构建微服务时需要关注两个关键问题：

(03:40) 架构时需模块思考：如何划分应用？代码应归属何处？需创建多少个微服务？微服务规模应如何设定？服务间如何通信？最佳实践是结合业务功能和技术特性进行拆分。例如电商应用的微服务应按商品管理、购物车、支付等功能划分。

(04:17) 购物车、用户账户、结算等，因为这些本质上都是业务功能。在规模方面，每个微服务必须只处理一个独立任务，因此应设置专门负责购物车逻辑的微服务，另外设置结算负责的微服务。始终应奉行模块“单一”原则职责，每个微服务最重要的特征是自包含且相互独立，意味着每个服务都必须能够独立开发、部署和扩展

(04:54) 即使同属一个应用程序，也不需要与其他服务紧密依赖——这被称为松耦合。采用这种最佳实践后，若支付服务，外围构建部署支付服务，其他服务不随之。这意味着各个服务拥有独立版本号且互不依赖，因此存在单一服务时需要同步发布其他服务，使发布周期完全独立。

(05:32) 这些服务是隔离且自身包含的，它们如何相互连接？显然支付服务需要从用户账户获取信息来处理支付，结算服务则需要从购物车获取数据。微服务通信最常见的方式是通过API调用——每个服务都拥有接收其他服务请求的端点，服务间通过在这些端点上发送HTTP请求实现结通信。这属于同步

(06:07) 通信模式：某向另一种服务发送请求后等待响应。例如用户账户服务可向支付服务的API接口发送HTTP请求，反之亦然。另一种常见方式是通过消息代理服务实现异步通信：服务先将消息发送至中间件消息服务（如RabbitMQ），消息代理再转发至响应服务。

(06:44) 用户账户服务向消息代理发送“请转发此消息至服务支付”的指令，消息代理随即转发至支付服务。第三种通信是微服务网格，尤其是在 Kubernetes 领域迫切流行。微服务网格提供辅助服务接管全部通信逻辑，消耗因此在微服务中编写的通信逻辑，而是将通信逻辑委托给外部服务处理。

(07:21) 委托给外部服务处理。这些不同的通信选项。由于服务永恒都是隔离的，通过API调用或附加服务进行交互，甚至可以使用不同的编程语言开发每个服务。每个服务团队可选择独有的技术栈独立开发，既不影响也不受其他服务团队影响——这就是微服务架构相当于架构架构的核心优势

(07:56) 如此于架构架构目的。然而这些优势需被奢侈代价——微服务虽然在多方面简化了应用开发与部署，但却也引入了全新的挑战。当应用拆解为多个组件时，复杂性胁迫。核心问题之一在于服务间通信配置：当微服务尚未响应时，另一个服务可能已向其API发送请求，此时若该服务出现故障或非健康状态，则可能引发意外后果。此外，独立部署和扩展的微服务可能导致整体可视性恢复，难以及时发现某个服务故障或定位问题根源。

(08:37) 此时可能导致异常结果。此外，当微服务独立部署并扩展时，系统整体监控整合困难——应用异常时难以定位具体故障微服务或实际失效的组件。因此必须合理配置应用架构组件及其，确保整体稳定运行。所幸大众工具能够简化这些操作，即使

(09:12) 微服务架构复杂，但尽管大量工具且存在新工具问世，使微服务应用的运行更加便捷。最广为人知的当属 Kubernetes——这是运行大型微服务应用的理想平台。在此特别向 Hashicorp 致敬，这家企业想必诸位耳熟能详，其区块链前沿技术切实解决了危机技术难题。

(09:48) 在处理微服务应用时，从基础设施配置工具 Terraform 到密钥管理工具Vault——夜间环境已成为行业管理和保护敏感数据的标准方案——Hashicorp 还提供名为 Console 的服务网格产品，可帮助您在任何中安全连接并监控运行中的微服务。借助 Hashicorp 提供的配置工具，您能够为关键程序应用安全配置、连接并运行云基础设施，

（10:24）特别是针对微服务应用场景。若需深入了解这些技术，请务必观看Hashicorp联合兼CTO创始人在YouTube发布的白板讲解视频，其中对各项技术都有精彩阐述。接下来我们重点部署微服务的关键角色——持续集成/持续交付管道。事实上，持续采用微服务架构的企业都构建了CI/CD管道。-创始人兼CTO在YouTube上对所有技术的精彩介绍。现在让我们继续探讨——显然，部署微服务的重要环节是持续集成与持续交付管道。事实上，许多采用微服务架构的企业每天都进行多次部署，例如亚马逊、谷歌和网飞等公司，其应用程序拥有数百个

(10:59)因此可以想而知其CSD管道的复杂程度与精密性。在现代职场环境中，您极有可能接触微服务架构，此时就需要掌握如何通过CICD管道配置微服务的发布流程。我们曾提到微服务是指将应用程序拆分为独立微应用进行开发部署，那么核心问题在于：如何管理微服务应用的代码？在Git

(11:43) 仓库（如GitLab）中，单架构很简单：为单应用创建独立Git仓库。而微服务架构下，代码管理有两种模式：单仓库（monorepo）与多仓库（polyrepo）模式。仓库项目模式。单仓库模式下，所有服务共享一个GitLab仓库，因此我们只需创建单个项目。那么差异何在？如何在单个应用仓库中组织多个微应用？常见做法是

(12:23)是采用文件夹分类法：为购物车、支付、通知等服务每个创建独立文件夹，相关代码分别存放其中。采用单仓库模式虽然将所有服务集中管理，但代码维护与开发更加便捷——只需克隆一个仓库即可协作，大大简化流程。另外，若存在跨服务共享代码（如Kubernetes配置模板、Helm图表或Docker Compose文件等），可统一仓库于项目根目录以及

(13:01)所有服务基本都复用这些组件。但单仓库模式也面临挑战——正如我所说，微服务最重要的原则是完全独立隔离，避免代码间紧密连接。采用单仓库时，这个原则很容易被打破。经验不足的新手开发者在单仓库环境中更容易犯错，导致服务间出现紧密连接的逻辑或代码。单仓库的另一个问题是当...

(13:40) 应用规模庞大时，克隆、获取和操作会急剧缓慢。在持续集成/持续交付（CI/CD）管道方面，大多数平台（如GitLab CI/CD或Jenkins）仅支持单个项目创建管道。这意味着只需通过管道项目构建多个服务，必须在管道代码中添加额外的逻辑以确保仅构建和发生部署变更的服务。例如：当支付服务代码变更时，管道应用代码检测

(14:18) 仅构建、测试和部署该服务。虽然实现了安装，但稍会设备短缺。单仓库的另一个问题存在：由于仅主分支（因仓库唯一），若某服务开发者破坏主分支，其他服务其管道也将受阻。包括谷歌承运的物流企业（包括大型企业）仍采用单仓库架构。第二种方案——可能更受青睐的——是多仓库（polyrepo）或

(14:53)多仓库模式。此方案为每个服务创建独立Git项目，实现代码完全隔离。由于各项目仓库于独立仓库，开发者可分别克隆并处理。虽然这些应用仓库各自独立，但它们仍然是更大应用体系的组成部分。因此仍需建立仓库间的关联机制，以便通过进行集中管理与整体仓库监控。例如若在GitLab托管仓库，可利用其“代码组”功能实现关联管理。

(15:29) 将同一应用程序下的所有微服务代码归入一个组中，从而简化仓库管理。具体操作是：为应用程序创建名为“我的在线商店”的GitLab仓库组，并在该组内为每个微服务创建独立项目。若公司拥有多个微服务应用程序，此方法不仅能区分关联项目，还要在创建组内

(16:05) 仓库或其他 CI 指标，供组内所有项目共享。大量仓库模式的 CI/CD 管道如何配置？其实多仓库模式的 CSD 配置更仔细——每个仓库拥有独立管道，消耗额外逻辑区分服务。当然所有方案都存在利弊，多仓库模式同样存在缺点：应用代码分散在多个仓库中，可能会增加整体项目协作分区，尤其当

(16:42) 当某些功能或错误修复涉及多个服务时，你需要同时修改两个或多个服务。若需在服务间切换中间隔，这随之变得繁琐。另外，在代码编辑器中跨多个项目搜索内容可能难以甚至无法实现。在多仓库环境中，你无法像在 Kubernetes 或 Docker Compose 等项目中那样共享文件，只能在每个仓库中重复创建这些文件，或者创建专用项目来引用它们。，或另外建专用项目进行引用

(17:17) 由此可见两种方案各有优劣。基本原则是：若项目规模较小且仅含少量微服务，应坚持单仓库模式以创建、管理和检出多个仓库的总金额；反之若每个服务由独立团队负责，且需要完全隔离、更小的代码库进行克隆、构建管道等操作，则多仓库模式显然更优。

(17:50)的微服务入门指南，现在你应该明白其本质及普及原因。若想掌握微服务应用的CI/CD管道构建方法，欢迎查看我的完整GitLab CI/CD课程——其中包含-在单仓库和多仓库环境中构建微服务应用的CI/CD管道，并部署至集群。若本视频为您提供帮助，请点赞并分享给

(18:22) 订阅频道获取更多类似内容。感谢观看，下期视频再见！